filter {
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, pref_label_id
                  FROM about WHERE metadata_id = :metadata_id"
    target => "about"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, pref_label_id
                  FROM audience WHERE metadata_id = :metadata_id"
    target => "audience"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, encoding_format, in_language, type
                  FROM caption WHERE metadata_id = :metadata_id"
    target => "caption"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT c.identifier as id, c.name, c.type, c.honorific_prefix,
                  a.identifier as affiliation_identifier,
                  a.name as affiliation_name,
                  a.type as affiliation_type
                  FROM contributor c
                  LEFT JOIN affiliation a on c.affiliation_id = a.id
                  WHERE c.metadata_id = :metadata_id"
    target => "contributor"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT c.identifier as id, c.name, c.type, c.honorific_prefix,
                  a.identifier as affiliation_identifier,
                  a.name as affiliation_name,
                  a.type as affiliation_type
                  FROM creator c
                  LEFT JOIN affiliation a on c.affiliation_id = a.id
                  WHERE c.metadata_id = :metadata_id"
    target => "creator"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, pref_label_id
                  FROM learning_resource_type WHERE metadata_id = :metadata_id"
    target => "learningResourceType"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT md.identifier as id,
                  md.type,
                  md.date_created as date_created,
                  md.date_modified as date_modified,
                  p.identifier as provider_identifier,
                  p.type as provider_type,
                  p.name as provider_name
                  FROM main_entity_of_page md
                  LEFT JOIN provider p on md.provider_id = p.id
                  WHERE metadata_id = :metadata_id"
    target => "mainEntityOfPage"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, name, type
                  FROM publisher WHERE metadata_id = :metadata_id"
    target => "publisher"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT identifier as id, name, type
                  FROM source_organization WHERE metadata_id = :metadata_id"
    target => "sourceOrganization"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT ls.label, ls.language_code, lrt.pref_label_id
                  FROM learning_resource_type lrt
                  LEFT JOIN localized_string ls ON lrt.pref_label_id = ls.pref_label_id
                  WHERE metadata_id = :metadata_id"
    target => "learningResourceTypeLabels"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT ls.label, ls.language_code, a.pref_label_id
                  FROM audience a
                  LEFT JOIN localized_string ls ON a.pref_label_id = ls.pref_label_id
                  WHERE metadata_id = :metadata_id"
    target => "audienceLabels"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "conditions_of_access_pref_label_id" => "conditions_of_access_pref_label_id"}
    statement => "SELECT ls.label, ls.language_code
                  FROM localized_string ls
                  WHERE ls.pref_label_id = :conditions_of_access_pref_label_id"
    target => "conditionsOfAccessLabels"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT ls.label, ls.language_code, a.pref_label_id
                  FROM about a
                  LEFT JOIN localized_string ls ON a.pref_label_id = ls.pref_label_id
                  WHERE metadata_id = :metadata_id"
    target => "aboutLabels"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT keywords FROM keywords WHERE metadata_id = :metadata_id"    
    target => "keywords"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT type FROM types WHERE metadata_id = :metadata_id"    
    target => "tmptype"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT in_language FROM in_language WHERE metadata_id = :metadata_id"    
    target => "inLanguage"
  }
  jdbc_streaming  {
    jdbc_connection_string => "jdbc:mariadb://{{ mariadb_host }}:{{ mariadb_port }}/{{ oerindex_db.name }}"
    jdbc_user => "{{ oerindex_db.user }}"
    jdbc_password => "{{ oerindex_db.password }}"
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
    jdbc_driver_class => "org.mariadb.jdbc.Driver"
    parameters => { "metadata_id" => "internal_id"}
    statement => "SELECT bitrate, embed_url, content_size, content_url, encoding_format, sha256, type FROM media WHERE metadata_id = :metadata_id"
    target => "encoding"
  }
  ruby {
    code => "
      filled_keywords = event.get('keywords').find_all { |k| k['keywords'] != nil }
      keywords = filled_keywords.collect { |k| k['keywords'] }
      event.set('keywords', keywords)

      types = event.get('tmptype').find_all { |k| k['type'] != nil }.collect { |k| k['type'] }
      event.set('tmptype', types)
      
      languages = event.get('inLanguage').find_all { |k| k['in_language'] != nil }.collect { |k| k['in_language'] }
      event.set('inLanguage', languages)
    "
  }
  ruby {
    # set prefLabels and remove helper variables
    code => '
      def set_pref_labels(labels, entity_field_name, event)
        labels.each do |ls|
          unless ls["language_code"].nil?
            event.set(entity_field_name + "[prefLabel][" + ls["language_code"] + "]", ls["label"])
          end
        end
      end
      
      def set_pref_labels_for_array(array_field_name, labels_field_name, event)
        event.get(array_field_name).each_with_index do |a, index|
          labels = []
          event.get(labels_field_name).each do |l|
            unless l["pref_label_id"].nil?
              if a["pref_label_id"] === l["pref_label_id"]
                labels << l
              end
              set_pref_labels(labels, "[" + array_field_name + "][#{index}]", event)
            end
            event.remove("[" + array_field_name + "][#{index}][pref_label_id]")
          end
        end
      end
      set_pref_labels_for_array("about", "aboutLabels", event)
      event.remove("aboutLabels")
      set_pref_labels_for_array("learningResourceType", "learningResourceTypeLabels", event)
      event.remove("learningResourceTypeLabels")
      set_pref_labels_for_array("audience", "audienceLabels", event)
      event.remove("audienceLabels")

      set_pref_labels(event.get("[conditionsOfAccessLabels]"), "[conditionsOfAccess]", event)
      event.remove("conditionsOfAccessLabels")
      event.remove("conditions_of_access_pref_label_id")
      event.set("[conditionsOfAccess][type]", event.get("[conditions_of_access_type]")) unless event.get("[conditions_of_access_type]").nil?
      event.remove("conditions_of_access_type")
      event.set("[conditionsOfAccess][id]", event.get("[conditions_of_access_id]")) unless event.get("[conditions_of_access_id]").nil?
      event.remove("conditions_of_access_id")
    '
  }
  ruby {
    code => '
      event.get("encoding").each_with_index do |e, index|
        contentSize = event.get("[encoding][#{index}][content_size]")
        event.set("[encoding][#{index}][contentSize]", contentSize) unless contentSize.nil?
        contentUrl = event.get("[encoding][#{index}][content_url]")
        event.set("[encoding][#{index}][contentUrl]", contentUrl) unless contentUrl.nil?
        embedUrl = event.get("[encoding][#{index}][embed_url]")
        event.set("[encoding][#{index}][embedUrl]", embedUrl) unless embedUrl.nil?
        encodingFormat = event.get("[encoding][#{index}][encoding_format]")
        event.set("[encoding][#{index}][encodingFormat]", encodingFormat) unless encodingFormat.nil?

        item = event.get("[encoding][#{index}]")
        item.delete("content_size")
        item.delete("content_url")
        item.delete("embed_url")
        item.delete("encoding_format")
        event.set("[encoding][#{index}]", item)
      end

      event.set("[trailer][bitrate]", event.get("[trailer_bitrate]")) unless event.get("[trailer_bitrate]").nil?
      event.remove("trailer_bitrate")
      event.set("[trailer][embedUrl]", event.get("[trailer_embed_url]")) unless event.get("[trailer_embed_url]").nil?
      event.remove("trailer_embed_url")
      event.set("[trailer][contentSize]", event.get("[trailer_content_size]")) unless event.get("[trailer_content_size]").nil?
      event.remove("trailer_content_size")
      event.set("[trailer][contentUrl]", event.get("[trailer_content_url]")) unless event.get("[trailer_content_url]").nil?
      event.remove("trailer_content_url")
      event.set("[trailer][encodingFormat]", event.get("[trailer_encoding_format]")) unless event.get("[trailer_encoding_format]").nil?
      event.remove("trailer_encoding_format")
      event.set("[trailer][sha256]", event.get("[trailer_sha256]")) unless event.get("[trailer_sha256]").nil?
      event.remove("trailer_sha256")
      event.set("[trailer][type]", event.get("[trailer_type]")) unless event.get("[trailer_type]").nil?
      event.remove("trailer_type")

      event.get("caption").each_with_index do |e, index|
        encodingFormat = event.get("[caption][#{index}][encoding_format]")
        event.set("[caption][#{index}][encodingFormat]", encodingFormat) unless encodingFormat.nil?
        inLanguage = event.get("[caption][#{index}][in_language]")
        event.set("[caption][#{index}][inLanguage]", inLanguage) unless inLanguage.nil?

        item = event.get("[caption][#{index}]")
        item.delete("encoding_format")
        item.delete("in_language")
        event.set("[caption][#{index}]", item)
      end      
    '
  }
  ruby {
    code => '
      def rename_field_if_set(old_field_name, new_field_name, item)
        value = item[old_field_name]
        unless value.nil?
          item[new_field_name] = value
        end
        item.delete(old_field_name)
      end
      def set_value_if_set(event, field, value)
        event.set(field, value) unless value.nil?
      end
      set_value_if_set(event, "[license][id]", event.get("license_id"))
      event.get("mainEntityOfPage").each_with_index do |md, index|
        provider_identifier = event.get("[mainEntityOfPage][#{index}][provider_identifier]")
        provider_type = event.get("[mainEntityOfPage][#{index}][provider_type]")
        provider_name = event.get("[mainEntityOfPage][#{index}][provider_name]")
        set_value_if_set(event, "[mainEntityOfPage][#{index}][provider][id]", provider_identifier)
        set_value_if_set(event, "[mainEntityOfPage][#{index}][provider][type]", provider_type)
        set_value_if_set(event, "[mainEntityOfPage][#{index}][provider][name]", provider_name)
        item = event.get("[mainEntityOfPage][#{index}]")
        item.delete("provider_identifier")
        item.delete("provider_type")
        item.delete("provider_name")
        rename_field_if_set("date_created", "dateCreated", item)
        rename_field_if_set("date_modified", "dateModified", item)
        event.set("[mainEntityOfPage][#{index}]", item)
      end
      event.get("contributor").each_with_index do |c, index|
        affiliation_identifier = event.get("[contributor][#{index}][affiliation_identifier]")
        affiliation_type = event.get("[contributor][#{index}][affiliation_type]")
        affiliation_name = event.get("[contributor][#{index}][affiliation_name]")
        honorific_prefix = event.get("[contributor][#{index}][honorific_prefix]")
        set_value_if_set(event, "[contributor][#{index}][affiliation][id]", affiliation_identifier)
        set_value_if_set(event, "[contributor][#{index}][affiliation][type]", affiliation_type)
        set_value_if_set(event, "[contributor][#{index}][affiliation][name]", affiliation_name)
        set_value_if_set(event, "[contributor][#{index}][honorificPrefix]", honorific_prefix)
        item = event.get("[contributor][#{index}]")
        item.delete("affiliation_identifier")
        item.delete("affiliation_type")
        item.delete("affiliation_name")
        item.delete("honorific_prefix")
        event.set("[contributor][#{index}]", item)
      end
      event.get("creator").each_with_index do |c, index|
        affiliation_identifier = event.get("[creator][#{index}][affiliation_identifier]")
        affiliation_type = event.get("[creator][#{index}][affiliation_type]")
        affiliation_name = event.get("[creator][#{index}][affiliation_name]")
        honorific_prefix = event.get("[creator][#{index}][honorific_prefix]")
        set_value_if_set(event, "[creator][#{index}][affiliation][id]", affiliation_identifier)
        set_value_if_set(event, "[creator][#{index}][affiliation][type]", affiliation_type)
        set_value_if_set(event, "[creator][#{index}][affiliation][name]", affiliation_name)
        set_value_if_set(event, "[creator][#{index}][honorificPrefix]", honorific_prefix)
        item = event.get("[creator][#{index}]")
        item.delete("affiliation_identifier")
        item.delete("affiliation_type")
        item.delete("affiliation_name")
        item.delete("honorific_prefix")
        event.set("[creator][#{index}]", item)
      end
    '
  }
  ruby {
    code => '
      event.set("[@metadata][doc_id]", Base64.urlsafe_encode64(event.get("id")))
    '
  }
  ruby {
    code => '
      uri = event.get("context_uri")
      lng = event.get("context_language")
      unless uri.nil? || lng.nil?
        context = []
        context << uri
        context << { "@language" => lng }
        event.set("[@context]", context)
      end
    '
  }
  mutate {
    rename => { 
      "date_created" => "dateCreated"
      "date_published" => "datePublished"
      "is_accessible_for_free" => "isAccessibleForFree"
    }
    add_field => {
      "[@metadata][internal_id]" => "%{internal_id}"
      "[@metadata][target_index]" => "${OER_INDEX_NAME}"
#      "[mainEntityOfPage][id]" => "{{ oerindex_backend_searchapi_url }}{{ elasticsearch_oer_index_alias_name }}/_doc/%{internal_id}"
#      "[mainEntityOfPage][dateModified]" => "%{date_modified_internal}"
    }
    remove_field => [
      "internal_id",
      "date_modified_internal",
      "context_uri", "context_language",
      "license_id"
    ]
  }
  clone {
    clones => ["internal"]
  }
  ruby {
    code => '
      if event.get("type") === "internal"
        event.set("[@metadata][target_index]", "${OER_INDEX_INTERNAL_NAME}")
        event.set("persons", event.get("creator").find_all { |k| k["type"] === "Person" })
        institutions = []
        institutions = institutions + event.get("creator").find_all { |k| k["type"] === "Organization" }
        institutions = institutions + event.get("creator").find_all { |k| k["affiliation"] }.map{ |k| k["affiliation"] }
        institutions = institutions + event.get("sourceOrganization")
        publisher_mappings = [
{% for whitelist_mapping in institution_from_publisher_whitelist %}
          { "regex" => /{{ whitelist_mapping.regex }}/, "name" => "{{ whitelist_mapping.name | default("\\\\1") }}" }{{ "," if not loop.last else "" }}
{% endfor %}
        ]
        event.get("publisher").each do |publisher|
          publisher_mappings.each do |mapping|
            if mapping["regex"].match(publisher["name"])
              publisher["name"] = publisher["name"].gsub(mapping["regex"], mapping["name"])
              institutions << publisher
              break
            end
          end
        end
        event.set("institutions", institutions)
      end
    '
  }
  mutate {
    remove_field => [
      "tags", "@version", "@timestamp", "type"
    ]
  }
  mutate {
    rename => { 
      "tmptype" => "type"
    }
  }
  ruby {
    # remove null values
    code => '
      def remove_null_fields(hash, path, event)
        hash.each do |k,v|
          if v.nil? or (v.is_a?(Hash) and v.empty?)
            event.remove(path + "[" + k + "]")
          elsif v.is_a?(Array)
            v.each_with_index do |item, index|
              remove_null_fields(item, path + "[" + k + "][#{index}]", event) if item.is_a?(Hash)
            end
            v = event.get(path + "[" + k + "]")
            if v.empty?
              event.remove(path + "[" + k + "]")
            end
          end
        end
        event.remove(path) if hash.empty?
      end
      remove_null_fields(event.to_hash, "", event)
    '
  }
}